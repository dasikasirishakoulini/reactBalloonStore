function g() {
  return (g = Object.assign || function(a) {
    var d, e, b;
    for (d = 1; d < arguments.length; d++) {
      e = arguments[d];
      for (b in e) {
        Object.prototype.hasOwnProperty.call(e, b) && (a[b] = e[b]);
      }
    }
    return a;
  }).apply(this, arguments);
}

function m(a) {
  return a && a.networkError;
}

import { makeOperation } from "@urql/core";

import { share, makeSubject, mergeMap, filter, takeUntil, delay, fromValue, merge } from "wonka";

export function retryExchange(a) {
  var d = a.initialDelayMs || 1e3, e = a.maxDelayMs || 15e3, b = a.maxNumberAttempts || 2, n = a.randomDelay || !0, p = a.retryIf || m;
  return function(a) {
    var q = a.forward, k = a.dispatchDebug;
    return function(a) {
      var r, t, l = share(a);
      r = (a = makeSubject()).source, t = a.next;
      a = mergeMap((function(a) {
        var f, u = a.key, c = a.context, h = (c.retryCount || 0) + 1;
        c = c.retryDelay || d;
        f = Math.random() + 1.5;
        n && c * f < e && (c *= f);
        f = filter((function(a) {
          return ("query" === a.kind || "teardown" === a.kind) && a.key === u;
        }))(l);
        "production" !== process.env.NODE_ENV && k({
          type: "retryAttempt",
          message: "The operation has failed and a retry has been triggered (" + h + " / " + b + ")",
          operation: a,
          data: {
            retryCount: h
          },
          source: "retryExchange"
        });
        return takeUntil(f)(delay(c)(fromValue(makeOperation(a.kind, a, g({}, a.context, {
          retryDelay: c,
          retryCount: h
        })))));
      }))(r);
      return filter((function(a) {
        if (!a.error || !p(a.error, a.operation)) {
          return !0;
        }
        if (!((a.operation.context.retryCount || 0) >= b - 1)) {
          return t(a.operation), !1;
        }
        "production" !== process.env.NODE_ENV && k({
          type: "retryExhausted",
          message: "Maximum number of retries has been reached. No further retries will be performed.",
          operation: a.operation,
          source: "retryExchange"
        });
        return !0;
      }))(share(q(merge([ l, a ]))));
    };
  };
}
//# sourceMappingURL=urql-exchange-retry.mjs.map
