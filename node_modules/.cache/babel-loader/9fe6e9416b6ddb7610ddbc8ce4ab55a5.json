{"ast":null,"code":"function _extends() {\n  return (_extends = Object.assign || function (target) {\n    var i, source, key;\n\n    for (i = 1; i < arguments.length; i++) {\n      source = arguments[i];\n\n      for (key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  }).apply(this, arguments);\n}\n\nfunction useMutation(query) {\n  function _ref(result) {\n    if (isMounted.current) {\n      setState({\n        fetching: !1,\n        stale: !!result.stale,\n        data: result.data,\n        error: result.error,\n        extensions: result.extensions,\n        operation: result.operation\n      });\n    }\n\n    return result;\n  }\n\n  function _ref2() {\n    isMounted.current = !1;\n  }\n\n  var isMounted = useRef(!0),\n      client = useClient(),\n      ref = useState(initialState),\n      state = ref[0],\n      setState = ref[1],\n      executeMutation = useCallback(function (variables, context) {\n    setState(_extends({}, initialState, {\n      fetching: !0\n    }));\n    return toPromise(client.executeMutation(createRequest(query, variables), context || {})).then(_ref);\n  }, [client, query, setState]);\n  useEffect(function () {\n    return _ref2;\n  }, []);\n  return [state, executeMutation];\n}\n\nfunction useRequest(query, variables) {\n  var prev = useRef(void 0);\n  return useMemo(function () {\n    var request = createRequest(query, variables);\n\n    if (void 0 !== prev.current && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n\nfunction useQuery(args) {\n  function _ref(result) {\n    cache.set(request.key, result);\n  }\n\n  var client = useClient(),\n      cache = getCacheForClient(client),\n      suspense = isSuspense(client, args.context),\n      request = useRequest(args.query, args.variables),\n      source = useMemo(function () {\n    if (args.pause) {\n      return null;\n    }\n\n    var source = client.executeQuery(request, _extends({}, {\n      requestPolicy: args.requestPolicy\n    }, args.context));\n    return suspense ? onPush(_ref)(source) : source;\n  }, [client, request, suspense, args.pause, args.requestPolicy, args.context]),\n      getSnapshot = useCallback(function (source, suspense) {\n    var result, resolve, subscription, promise;\n\n    if (!source) {\n      return {\n        fetching: !1\n      };\n    }\n\n    if (!(result = cache.get(request.key))) {\n      subscription = subscribe(function _ref2(_result) {\n        result = _result;\n\n        if (resolve) {\n          resolve(result);\n        }\n      })(takeWhile(function _ref3() {\n        return suspense && !resolve || !result;\n      })(source));\n\n      if (null == result && suspense) {\n        promise = new Promise(function _ref4(_resolve) {\n          resolve = _resolve;\n        });\n        cache.set(request.key, promise);\n        throw promise;\n      } else {\n        subscription.unsubscribe();\n      }\n    } else if (suspense && null != result && \"then\" in result) {\n      throw result;\n    }\n\n    return result || {\n      fetching: !0\n    };\n  }, [request]),\n      deps = [client, request, args.requestPolicy, args.context, args.pause],\n      ref = useState(function () {\n    currentInit = !0;\n\n    try {\n      return [source, computeNextState(initialState, getSnapshot(source, suspense)), deps];\n    } finally {\n      currentInit = !1;\n    }\n  }),\n      state = ref[0],\n      setState = ref[1],\n      currentResult = state[1];\n\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([source, currentResult = computeNextState(state[1], getSnapshot(source, suspense)), deps]);\n  }\n\n  useEffect(function () {\n    var subscription,\n        source = state[0],\n        request = state[2][1],\n        hasResult = !1,\n        updateResult = function updateResult(result) {\n      hasResult = !0;\n\n      if (!currentInit) {\n        setState(function _ref5(state) {\n          var nextResult = computeNextState(state[1], result);\n          return state[1] !== nextResult ? [state[0], nextResult, state[2]] : state;\n        });\n      }\n    };\n\n    if (source) {\n      subscription = subscribe(updateResult)(onEnd(function _ref6() {\n        updateResult({\n          fetching: !1\n        });\n      })(source));\n\n      if (!hasResult) {\n        updateResult({\n          fetching: !0\n        });\n      }\n\n      return function _ref7() {\n        cache.dispose(request.key);\n        subscription.unsubscribe();\n      };\n    } else {\n      updateResult({\n        fetching: !1\n      });\n    }\n  }, [cache, state[0], state[2][1]]);\n  return [currentResult, useCallback(function (opts) {\n    var context = _extends({}, {\n      requestPolicy: args.requestPolicy\n    }, args.context, opts),\n        source = client.executeQuery(request, context);\n\n    setState(function (state) {\n      var snapshot = \"network-only\" !== context.requestPolicy ? getSnapshot(source, !1) : {\n        fetching: !0\n      },\n          nextResult = computeNextState(state[1], snapshot);\n      return state[1] !== nextResult ? [source, nextResult, state[2]] : state;\n    });\n  }, [client, request, getSnapshot, args.requestPolicy, args.context])];\n}\n\nfunction useSubscription(args, handler) {\n  function _ref(result) {\n    setState(function (state) {\n      var nextResult = computeNextState(state[1], result);\n\n      if (state[1] === nextResult) {\n        return state;\n      }\n\n      if (handlerRef.current && state[1].data !== nextResult.data) {\n        nextResult.data = handlerRef.current(state[1].data, nextResult.data);\n      }\n\n      return [state[0], nextResult, state[2]];\n    });\n  }\n\n  var source,\n      deps,\n      ref,\n      state,\n      setState,\n      currentResult,\n      client = useClient(),\n      request = useRequest(args.query, args.variables),\n      handlerRef = useRef(handler);\n  handlerRef.current = handler;\n  source = useMemo(function () {\n    return !args.pause ? client.executeSubscription(request, args.context) : null;\n  }, [client, request, args.pause, args.context]);\n  deps = [client, request, args.context, args.pause];\n  ref = useState(function () {\n    return [source, _extends({}, initialState, {\n      fetching: !!source\n    }), deps];\n  });\n  setState = ref[1];\n  currentResult = (state = ref[0])[1];\n\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([source, currentResult = computeNextState(state[1], {\n      fetching: !!source\n    }), deps]);\n  }\n\n  useEffect(function () {\n    var updateResult = _ref;\n\n    if (state[0]) {\n      return subscribe(updateResult)(onEnd(function _ref2() {\n        updateResult({\n          fetching: !1\n        });\n      })(state[0])).unsubscribe;\n    } else {\n      updateResult({\n        fetching: !1\n      });\n    }\n  }, [state[0]]);\n  return [currentResult, useCallback(function (opts) {\n    var source = client.executeSubscription(request, _extends({}, args.context, opts));\n    setState(function (state) {\n      return [source, state[1], state[2]];\n    });\n  }, [client, args.context, request])];\n}\n\nfunction Mutation(props) {\n  var mutation = useMutation(props.query);\n  return props.children(_extends({}, mutation[0], {\n    executeMutation: mutation[1]\n  }));\n}\n\nfunction Query(props) {\n  var query = useQuery(props);\n  return props.children(_extends({}, query[0], {\n    executeQuery: query[1]\n  }));\n}\n\nfunction Subscription(props) {\n  var subscription = useSubscription(props, props.handler);\n  return props.children(_extends({}, subscription[0], {\n    executeSubscription: subscription[1]\n  }));\n}\n\nvar defaultClient, Context, Provider, Consumer, hasWarnedAboutDefault, useClient, initialState, isShallowDifferent, computeNextState, hasDepsChanged, getCacheForClient, isSuspense, currentInit;\nimport { createClient, createRequest } from \"@urql/core\";\nexport * from \"@urql/core\";\nimport { createContext, useContext, useRef, useState, useCallback, useEffect, useMemo } from \"react\";\nimport { toPromise, subscribe, onPush, takeWhile, onEnd } from \"wonka\";\ndefaultClient = createClient({\n  url: \"/graphql\"\n});\nProvider = (Context = createContext(defaultClient)).Provider;\nConsumer = Context.Consumer;\nhasWarnedAboutDefault = !1;\n\nuseClient = function useClient() {\n  var client = useContext(Context);\n\n  if (\"production\" !== process.env.NODE_ENV && client === defaultClient && !hasWarnedAboutDefault) {\n    hasWarnedAboutDefault = !0;\n    console.warn(\"Default Client: No client has been specified using urql's Provider.This means that urql will be falling back to defaults including making requests to `/graphql`.\\nIf that's not what you want, please create a client and add a Provider.\");\n  }\n\n  return client;\n};\n\ninitialState = {\n  fetching: !1,\n  stale: !1,\n  error: void 0,\n  data: void 0,\n  extensions: void 0,\n  operation: void 0\n};\n\nisShallowDifferent = function isShallowDifferent(a, b) {\n  var x, x$1;\n\n  if (\"object\" != typeof a || \"object\" != typeof b) {\n    return a !== b;\n  }\n\n  for (x in a) {\n    if (!(x in b)) {\n      return !0;\n    }\n  }\n\n  for (x$1 in b) {\n    if (a[x$1] !== b[x$1]) {\n      return !0;\n    }\n  }\n\n  return !1;\n};\n\ncomputeNextState = function computeNextState(prevState, result) {\n  var newState = _extends({}, prevState, result, {\n    fetching: !!result.fetching,\n    stale: !!result.stale\n  });\n\n  return isShallowDifferent(prevState, newState) ? newState : prevState;\n};\n\nhasDepsChanged = function hasDepsChanged(a, b) {\n  for (var i = 0, l = b.length; i < l; i++) {\n    if (a[i] !== b[i]) {\n      return !0;\n    }\n  }\n\n  return !1;\n};\n\ngetCacheForClient = function getCacheForClient(client) {\n  var reclaim, map;\n\n  if (!client._react) {\n    reclaim = new Set();\n    map = new Map();\n\n    if (client.operations$) {\n      subscribe(function _ref(operation) {\n        if (\"teardown\" === operation.kind && reclaim.has(operation.key)) {\n          reclaim.delete(operation.key);\n          map.delete(operation.key);\n        }\n      })(client.operations$);\n    }\n\n    client._react = {\n      get: function _get(key) {\n        return map.get(key);\n      },\n      set: function _set(key, value) {\n        reclaim.delete(key);\n        map.set(key, value);\n      },\n      dispose: function _dispose(key) {\n        reclaim.add(key);\n      }\n    };\n  }\n\n  return client._react;\n};\n\nisSuspense = function isSuspense(client, context) {\n  return client.suspense && (!context || !1 !== context.suspense);\n};\n\ncurrentInit = !1;\nexport { Consumer, Context, Mutation, Provider, Query, Subscription, useClient, useMutation, useQuery, useSubscription };","map":{"version":3,"sources":["../src/hooks/useMutation.ts","../src/hooks/useRequest.ts","../src/hooks/useQuery.ts","../src/hooks/useSubscription.ts","../src/components/Mutation.ts","../src/components/Query.ts","../src/components/Subscription.ts","../src/context.ts","../src/hooks/state.ts","../src/hooks/cache.ts"],"names":["useMutation","query","isMounted","useRef","client","useClient","useState","initialState","executeMutation","useCallback","variables","context","setState","_extends","fetching","createRequest","toPromise","then","result","current","stale","data","error","extensions","operation","useEffect","state","useRequest","prev","undefined","useMemo","request","key","isSuspense","suspense","currentInit","const","cache","getCacheForClient","pause","args","getSnapshot","let","subscription","_ref4","promise","deps","source","currentResult","hasResult","nextResult","executeQuery","opts","handlerRef","computeNextState","useQuery","executeSubscription","handler","Context","Provider","hasWarnedAboutDefault","b","hasDepsChanged","a","i","l","length","_react","reclaim","Set","map","Map","operations$","subscribe","kind","has","delete","get","set","value","dispose","add"],"mappings":";;;;;;;;;;;;;;;;;;SAiCgBA,W,CACdC,K,EAAAA;gBAmBWiB,M,EAAAA;QACDhB,SAAAA,CAAUiB,O,EAAAA;AACZP,MAAAA,QAAAA,CAAS;AACPE,QAAAA,QAAAA,EAAAA,CAAU,CADH;AAEPM,QAAAA,KAAAA,EAAAA,CAAAA,CAASF,MAAAA,CAAOE,KAFT;AAGPC,QAAAA,IAAAA,EAAMH,MAAAA,CAAOG,IAHN;AAIPC,QAAAA,KAAAA,EAAOJ,MAAAA,CAAOI,KAJP;AAKPC,QAAAA,UAAAA,EAAYL,MAAAA,CAAOK,UALZ;AAMPC,QAAAA,SAAAA,EAAWN,MAAAA,CAAOM;AANX,OAATZ,CAAAA;;;WASKM,M;;;;AASThB,IAAAA,SAAAA,CAAUiB,OAAVjB,GAAUiB,CAAU,CAApBjB;;;MArCEA,SAAAA,GAAYC,MAAAA,CAAAA,CAAO,CAAPA,C;MACZC,MAAAA,GAASC,SAAAA,E;MAAAA,GAAAA,GAEWC,QAAAA,CACxBC,YADwBD,C;MACxBC,KAAAA,GAAAA,GAAAA,CAAAA,CAAAA,C;MAAAA,QAAAA,GAAAA,GAAAA,CAAAA,CAAAA,C;MAGIC,eAAAA,GAAkBC,WAAAA,CAAAA,UACrBC,SADqBD,EACEE,OADFF,EACEE;AACtBC,IAAAA,QAAAA,CAASC,QAAAA,CAAAA,EAAAA,EAAKN,YAALM,EAAKN;AAAcO,MAAAA,QAAAA,EAAAA,CAAU;AAAxBP,KAALM,CAATD,CAAAA;WAOEI,SAAAA,CAJAZ,MAAAA,CAAOI,eAAPJ,CACEW,aAAAA,CAA+Bd,KAA/Bc,EAAsCL,SAAtCK,CADFX,EAEEO,OAAAA,IAAW,EAFbP,CAIAY,CAAAA,CACAC,IADAD,CACAC,IADAD,C;GATkBP,E,CAyBrBL,M,EAAQH,K,EAAOW,Q,CAzBMH,C;AA4BxBgB,EAAAA,SAAAA,CAAAA,YAAAA;;GAAAA,EAIG,EAJHA,CAAAA;SAMO,CAACC,KAAD,EAAQlB,eAAR,C;;;SCxEOmB,U,CACd1B,K,EACAS,S,EAAAA;MAEMkB,IAAAA,GAAOzB,MAAAA,CAAAA,KAAoD0B,CAApD1B,C;SAEN2B,OAAAA,CAAAA,YAAAA;QACCC,OAAAA,GAAUhB,aAAAA,CAA+Bd,KAA/Bc,EAAsCL,SAAtCK,C;;aAEKc,C,KAAjBD,IAAAA,CAAKT,O,IAAyBS,IAAAA,CAAKT,OAALS,CAAaI,GAAbJ,KAAqBG,OAAAA,CAAQC,G,EAAAA;aACtDJ,IAAAA,CAAKT,O;WACP;AACLS,MAAAA,IAAAA,CAAKT,OAALS,GAAeG,OAAfH;aACOG,O;;GAPJD,EASJ,CAAC7B,KAAD,EAAQS,SAAR,CATIoB,C;;;ACwCPM,SAAAA,QAAAA,CAAAA,IAAAA,EAAAA;;;;;AAAAA,MACMC,MAAAA,GAAAA,SAAAA,EADND;AAAAA,MAEMF,KAAAA,GAAQI,iBAAAA,CAAAA,MAAAA,CAFdF;AAAAA,MAGML,QAAAA,GAAAA,UAAAA,CAAAA,MAAAA,EAAAA,IAAAA,CAAAA,OAAAA,CAHNK;AAAAA,MAGML,OAAAA,GAAAA,UAAAA,CAAAA,IAAAA,CAAAA,KAAAA,EAAAA,IAAAA,CAAAA,SAAAA,CAHNK;AAAAA,MAGML,MAAAA,GAAAA,OAAAA,CAAAA,YAAAA;aAGmBQ,K,EAAAA;;;;;qBAEvBH,IAAAA,CAAAA;;6CAayCI,M;GAlBrCT,E,CAoBAU,M,EAAAA,O,EAAAA,Q,EAAAA,IAAAA,CAAAA,K,EAAAA,IAAAA,CAGFP,a,EAAAA,IAAAA,CAAAA,O,CAvBEH,CAHNK;AAAAA,MA0BIF,WAAAA,GAAAA,WAAAA,CAAAA,UAAAA,MAAAA,EAAAA,QAAAA,EAAAA;gBAQQS,O,EAAAA,Y,EAAAA,O;;;;;;;;4CAFND;;;;;;;4BAImBR,K,GAAAA;;;;;sBAYCF,O,CAAAA,SAHTY,KAGSZ,CAHTY,QAGSZ,EAHTY;;;cAIHC,G,CAAAA,OAAAA,CAAAA,G,EAAAA,O;;;;;;;;;;;;GAvBVX,E,CAoCEY,O,CApCFZ,CA1BJE;AAAAA,MA8DMU,IAAAA,GAAAA,CAAAA,MAAAA,EAAAA,OAAAA,EAAAA,IAAAA,CAAAA,aAAAA,EAAAA,IAAAA,CAAAA,OAAAA,EAAAA,IAAAA,CAAAA,KAAAA,CA9DNV;AAAAA,MA8DMU,GAAAA,GAAAA,QAAAA,CAAAA,YAAAA;;;;cAgBMC,M,EAAAA,gBAAAA,CAAAA,YAAAA,EAAAA,WAAAA,CAAAA,MAAAA,EAAAA,QAAAA,CAAAA,C,EAAAA,I;AACRZ,K,SAAAA;;;GAjBEW,CA9DNV;AAAAA,M,cAAAA;AAAAA,MAmFIY,QAAAA,GAAAA,GAAAA,CAAAA,CAAAA,CAnFJZ;AAAAA,MAmFIY,aAAAA,GAAAA,KAAAA,CAAAA,CAAAA,CAnFJZ;;sDAuFqCU,I,GAAAA;;;;;;QAU7Bf,MAAAA,GAAAA,KAAAA,CAAe,CAAfA,C;QAEFkB,OAAAA,GAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,C;QAAAA,SAAAA,GAAAA,CAAAA,C;QAAAA,YAAAA,GAAAA,SAAAA,YAAAA,CAAAA,MAAAA,EAAAA;;;;;4CAQOvB,KAAAA,CAAM,CAANA,C,EAAUwB,M;;;;;;;;;AAUfpC,UAAAA,QAAAA,EAAAA,CAAAA;;;;;;AAKYA,UAAAA,QAAAA,EAAAA,CAAAA;;;;;AAId6B,QAAAA,KAAAA,CAAAA,OAAAA,CAAAA,OAAAA,CAAAA,GAAAA;;;;;AAGF7B,QAAAA,QAAAA,EAAAA,CAAAA;;;MAIEqC,K,EAAAA,KAAAA,CAAAA,CAAAA,C,EAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAA0B,CAA1BA,C;;;qBAKGC,IAAAA,CAHLhB;;;;;;;;wCAcoCW,KAAAA,CAAD,CAACA,C,EAAD,Q;AANnC,aAAA,KAAA,CAAA,CAAA,CAAA,KAAA,UAAA,GAAA,CAAA,MAAA,EAAA,UAAA,EAAA,KAAA,CAAA,CAAA,CAAA,CAAA,GAAA,KAAA;;uBAYGN,W,EAAAA,IAAAA,CAAAA,a,EAAAA,IAAAA,CAAAA,O;;;AClKPL,SAAAA,eAAAA,CAAAA,IAAAA,EAAAA,OAAAA,EAAAA;;uBAkCyBkB,K,EAAAA;;;;;;;kDAIVJ,UAAAA,CAAAA,I,EAAAA;;;;AALX,aAAA,CAAA,KAAA,CAAA,CAAA,CAAA,EAAA,UAAA,EAAA,KAAA,CAAA,CAAA,CAAA,CAAA;;;;AAjCJd,MAAAA,MAAAA;AAAAA,MAAAA,IAAAA;AAAAA,MAAAA,GAAAA;AAAAA,MAAAA,KAAAA;AAAAA,MAoBIY,QApBJZ;AAAAA,MAoBIY,aApBJZ;AAAAA,MACML,MAAAA,GAAAA,SAAAA,EADNK;AAAAA,MAGMiB,OAAAA,GAAU1B,UAAAA,CAAAA,IAAAA,CAAAA,KAAAA,EAAAA,IAAAA,CAAAA,SAAAA,CAHhBS;AAAAA,MAGgBT,UAAAA,GAAAA,MAAAA,CAAAA,OAAAA,CAHhBS;;;YAWEI,IAAAA,CAAAA,K,GAAAA,MAAAA,CAAAA,mBAAAA,CAAAA,OAAAA,EAAAA,IAAAA,CAAAA,OAAAA,C,GAAAA,I;MAGIM,M,EAAQ1C,O,EAAAA,IAAAA,CAAAA,K,EAAqBoC,IAAAA,CAAAA,O;;QAG1BO,QAAAA,CAAAA,YAAAA;;AAADjC,MAAAA,QAAAA,EAAAA,CAAAA,CAAAA;;GAACiC,C;AAGLC,EAAAA,QAAAA,GAAAA,GAAAA,CAAAA,CAAAA,CAAAA;;;sDAIiCF,I,GAAAA;cAAqBC,M,EAAAA,aAAAA,GAAAA,gBAAAA,CAAAA,KAAAA,CAAAA,CAAAA,CAAAA,EAAAA;AAF/CjC,MAAAA,QAAAA,EAAAA,CAAAA,CAAAA;AAE+CiC,KAAAA,C;;;;;;;;;AA2BlDjC,UAAAA,QAAAA,EAAAA,CAAAA;;;;;AAKJA,QAAAA,QAAAA,EAAAA,CAAAA;;;;;AAYAF,QAAAA,MAAAA,GAAAA,MAAAA,CAAAA,mBAAAA,CAAAA,OAAAA,EAAAA,QAAAA,CAAAA,EAAAA,EAAAA,IAAAA,CAAAA,OAAAA,EAAAA,IAAAA,CAAAA,CAAAA;aAAkB,UAAA,KAAA,EAAA;AAAlBA,aAAAA,CAAAA,MAAAA,EAAAA,KAAAA,CAAAA,CAAAA,CAAAA,EAAAA,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA;;;;;ACvFJwB,SAAAA,QAAAA,CAAAA,KAAAA,EAAAA;mCACsBnC,K;;AAAfO,IAAAA,eAAAA,EAAAA,QAAAA,CAAAA,CAAAA;;;;ACTP4B,SAAAA,KAAAA,CAAAA,KAAAA,EAAAA;cACYmB,QAAAA,CAALJ,KAAKI,C;wBAA6C1C,QAAAA,CAAAA,EAAAA,EAAAA,KAAAA,CAAAA,CAAAA,CAAAA,EAAAA;AAAlDsC,IAAAA,YAAAA,EAAAA,KAAAA,CAAAA,CAAAA;AAAkDtC,GAAAA,C;;;ACSzDuB,SAAAA,YAAAA,CAAAA,KAAAA,EAAAA;qCAMKO,K,EAAAA,KAAAA,CAAac,O;qCACiBd,YAAAA,CAAAA,CAAAA,C,EAAAA;AAF5Ba,IAAAA,mBAAAA,EAAAA,YAAAA,CAAAA,CAAAA;AAE4Bb,G;;;sCC3BxBe,Q,EACAC,qB,EAGTC,S,EAAAA,Y,EAAAA,kB,EAAAA,gB,ECwBSE,c,ECpBAxB,iB,EP4BPL,U,EAGFE,W;;;;;;;;;AKvCSuB,QAAAA,GAAAA,OAAAA,CAAAA,QAAAA;AACAC,qBAAAA,GAAAA,CAAAA,CAAAA;;AAGTC,SAAAA,GAAAA,qBAAAA;;;;;AAUAA,IAAAA,OAAAA,CAAAA,IAAAA,CAAAA,4OAAAA;;;;CAVAA;;;;ACVF9C,EAAAA,KAAAA,EAAAA,CAAAA,C;AACAM,EAAAA,KAAAA,EAAAA,KAAOS,C;AACPP,EAAAA,IAAAA,EAAAA,KAAAA,C;AACAD,EAAAA,UAAAA,EAAAA,KAAAA,C;AACAE,EAAAA,SAAAA,EAAAA,KAAAA;;;;;;;;;;;;;;;;;mBAOAsC,CAAAA,CAAAA,GAAAA,C,EAAAA;cAAwB,C;;;;;;;;;;AAgBtB/C,IAAAA,KAAAA,EAAAA,CAAAA,CAAAA,MAAAA,CAAAA;;;;;;AAOSgD,cAAAA,GAAAA,wBAAgDC,CAAhDD,EAAsDD,CAAtDC,EAAsDD;OAC5DnB,IAAIsB,CAAAA,GAAI,CAARtB,EAAWuB,CAAAA,GAAIJ,CAAAA,CAAEK,M,EAAQF,CAAAA,GAAIC,C,EAAGD,CAAAA,E,EAAAA;QAASD,CAAAA,CAAEC,CAAFD,CAAAA,KAASF,CAAAA,CAAEG,CAAFH,C,EAAEG;cAAW,C;;;;UAC7D,C;CAFIF;;ACpBAxB,iBAAAA,GAAAA,2BAAqBlC,MAArBkC,EAAqBlC;MAExBgE,O,EACAE,G;;OAFFlE,MAAAA,CAA2B+D,M,EAAQ;AACjCC,IAAAA,OAAAA,GAAU,IAAIC,GAAJ,EAAVD;AACAE,IAAAA,GAAAA,GAAM,IAAIC,GAAJ,EAAND;;QAEFlE,MAAAA,CAAOoE,W,EAAAA;AAGPC,MAAAA,SAAAA,CAAAA,SAAAA,IAAAA,CAAUjD,SAAViD,EAAUjD;YACe,eAAnBA,SAAAA,CAAUkD,IAAS,IAAcN,OAAAA,CAAQO,GAARP,CAAY5C,SAAAA,CAAUQ,GAAtBoC,C,EAA4B;AAC/DA,UAAAA,OAAAA,CAAQQ,MAARR,CAAe5C,SAAAA,CAAUQ,GAAzBoC;AACAE,UAAAA,GAAAA,CAAIM,MAAJN,CAAW9C,SAAAA,CAAUQ,GAArBsC;;AAHJG,OAAAA,CAAAA,CADArE,MAAAA,CAAOoE,WACPC;;;AASHrE,IAAAA,MAAAA,CAA2B+D,MAA3B/D,GAAoC;AACnCyE,MAAAA,GAAAA,EAAAA,SAAAA,IAAAA,CAAI7C,GAAJ6C,EAAI7C;eACKsC,GAAAA,CAAIO,GAAJP,CAAQtC,GAARsC,C;OAF0B;AAInCQ,MAAAA,GAAAA,EAAAA,SAAAA,IAAAA,CAAI9C,GAAJ8C,EAASC,KAATD,EAASC;AACPX,QAAAA,OAAAA,CAAQQ,MAARR,CAAepC,GAAfoC;AACAE,QAAAA,GAAAA,CAAIQ,GAAJR,CAAQtC,GAARsC,EAAaS,KAAbT;OANiC;AAQnCU,MAAAA,OAAAA,EAAAA,SAAAA,QAAAA,CAAQhD,GAARgD,EAAQhD;AACNoC,QAAAA,OAAAA,CAAQa,GAARb,CAAYpC,GAAZoC;;AATiC,KAApChE;;;SAcKA,MAAAA,CAA2B+D,M;CA/BxB7B;;AP4BPL,UAAAA,GAAAA,oBAAc7B,MAAd6B,EAA8BtB,OAA9BsB,EAA8BtB;SAClCP,MAAAA,CAAO8B,QAAP9B,KAAO8B,CAAcvB,OAAduB,IAAcvB,CAAgC,CAAhCA,KAAWA,OAAAA,CAAQuB,QAAxC9B,C;CADI6B;;AAGFE,WAAAA,GAAAA,CAAc,CAAdA","sourcesContent":["import { DocumentNode } from 'graphql';\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport { pipe, toPromise } from 'wonka';\n\nimport {\n  TypedDocumentNode,\n  OperationResult,\n  OperationContext,\n  CombinedError,\n  createRequest,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { initialState } from './state';\n\nexport interface UseMutationState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseMutationResponse<Data = any, Variables = object> = [\n  UseMutationState<Data, Variables>,\n  (\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<Data, Variables>>\n];\n\nexport function useMutation<Data = any, Variables = object>(\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string\n): UseMutationResponse<Data, Variables> {\n  const isMounted = useRef(true);\n  const client = useClient();\n\n  const [state, setState] = useState<UseMutationState<Data, Variables>>(\n    initialState\n  );\n\n  const executeMutation = useCallback(\n    (variables?: Variables, context?: Partial<OperationContext>) => {\n      setState({ ...initialState, fetching: true });\n\n      return pipe(\n        client.executeMutation<Data, Variables>(\n          createRequest<Data, Variables>(query, variables),\n          context || {}\n        ),\n        toPromise\n      ).then(result => {\n        if (isMounted.current) {\n          setState({\n            fetching: false,\n            stale: !!result.stale,\n            data: result.data,\n            error: result.error,\n            extensions: result.extensions,\n            operation: result.operation,\n          });\n        }\n        return result;\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [client, query, setState]\n  );\n\n  useEffect(() => {\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return [state, executeMutation];\n}\n","import { DocumentNode } from 'graphql';\nimport { useRef, useMemo } from 'react';\nimport { TypedDocumentNode, GraphQLRequest, createRequest } from '@urql/core';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */\nexport function useRequest<Data = any, Variables = object>(\n  query: string | DocumentNode | TypedDocumentNode<Data, Variables>,\n  variables?: Variables\n): GraphQLRequest<Data, Variables> {\n  const prev = useRef<undefined | GraphQLRequest<Data, Variables>>(undefined);\n\n  return useMemo(() => {\n    const request = createRequest<Data, Variables>(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n","// eslint-disable react-hooks/exhaustive-deps\n\nimport { DocumentNode } from 'graphql';\nimport { Source, pipe, subscribe, onEnd, onPush, takeWhile } from 'wonka';\nimport { useState, useEffect, useCallback, useMemo } from 'react';\n\nimport {\n  Client,\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  OperationResult,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\nimport { getCacheForClient } from './cache';\nimport { initialState, computeNextState, hasDepsChanged } from './state';\n\nexport interface UseQueryArgs<Variables = object, Data = any> {\n  query: string | DocumentNode | TypedDocumentNode<Data, Variables>;\n  variables?: Variables;\n  requestPolicy?: RequestPolicy;\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n}\n\nexport interface UseQueryState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseQueryResponse<Data = any, Variables = object> = [\n  UseQueryState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nconst isSuspense = (client: Client, context?: Partial<OperationContext>) =>\n  client.suspense && (!context || context.suspense !== false);\n\nlet currentInit = false;\n\nexport function useQuery<Data = any, Variables = object>(\n  args: UseQueryArgs<Variables, Data>\n): UseQueryResponse<Data, Variables> {\n  const client = useClient();\n  const cache = getCacheForClient(client);\n  const suspense = isSuspense(client, args.context);\n  const request = useRequest<Data, Variables>(args.query, args.variables);\n\n  const source = useMemo(() => {\n    if (args.pause) return null;\n\n    const source = client.executeQuery(request, {\n      requestPolicy: args.requestPolicy,\n      ...args.context,\n    });\n\n    return suspense\n      ? pipe(\n          source,\n          onPush(result => {\n            cache.set(request.key, result);\n          })\n        )\n      : source;\n  }, [client, request, suspense, args.pause, args.requestPolicy, args.context]);\n\n  const getSnapshot = useCallback(\n    (\n      source: Source<OperationResult<Data, Variables>> | null,\n      suspense: boolean\n    ): Partial<UseQueryState<Data, Variables>> => {\n      if (!source) return { fetching: false };\n\n      let result = cache.get(request.key);\n      if (!result) {\n        let resolve: (value: unknown) => void;\n\n        const subscription = pipe(\n          source,\n          takeWhile(() => (suspense && !resolve) || !result),\n          subscribe(_result => {\n            result = _result;\n            if (resolve) resolve(result);\n          })\n        );\n\n        if (result == null && suspense) {\n          const promise = new Promise(_resolve => {\n            resolve = _resolve;\n          });\n\n          cache.set(request.key, promise);\n          throw promise;\n        } else {\n          subscription.unsubscribe();\n        }\n      } else if (suspense && result != null && 'then' in result) {\n        throw result;\n      }\n\n      return (result as OperationResult<Data, Variables>) || { fetching: true };\n    },\n    [request]\n  );\n\n  const deps = [\n    client,\n    request,\n    args.requestPolicy,\n    args.context,\n    args.pause,\n  ] as const;\n\n  const [state, setState] = useState(() => {\n    currentInit = true;\n    try {\n      return [\n        source,\n        computeNextState(initialState, getSnapshot(source, suspense)),\n        deps,\n      ] as const;\n    } finally {\n      currentInit = false;\n    }\n  });\n\n  let currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([\n      source,\n      (currentResult = computeNextState(\n        state[1],\n        getSnapshot(source, suspense)\n      )),\n      deps,\n    ]);\n  }\n\n  useEffect(() => {\n    const source = state[0];\n    const request = state[2][1];\n\n    let hasResult = false;\n\n    const updateResult = (result: Partial<UseQueryState<Data, Variables>>) => {\n      hasResult = true;\n      if (!currentInit) {\n        setState(state => {\n          const nextResult = computeNextState(state[1], result);\n          return state[1] !== nextResult\n            ? [state[0], nextResult, state[2]]\n            : state;\n        });\n      }\n    };\n\n    if (source) {\n      const subscription = pipe(\n        source,\n        onEnd(() => {\n          updateResult({ fetching: false });\n        }),\n        subscribe(updateResult)\n      );\n\n      if (!hasResult) updateResult({ fetching: true });\n\n      return () => {\n        cache.dispose(request.key);\n        subscription.unsubscribe();\n      };\n    } else {\n      updateResult({ fetching: false });\n    }\n  }, [cache, state[0], state[2][1]]);\n\n  const executeQuery = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const context = {\n        requestPolicy: args.requestPolicy,\n        ...args.context,\n        ...opts,\n      };\n\n      const source = client.executeQuery(request, context);\n\n      setState(state => {\n        const snapshot =\n          context.requestPolicy !== 'network-only'\n            ? getSnapshot(source, false)\n            : { fetching: true };\n        const nextResult = computeNextState(state[1], snapshot);\n        return state[1] !== nextResult ? [source, nextResult, state[2]] : state;\n      });\n    },\n    [client, request, getSnapshot, args.requestPolicy, args.context]\n  );\n\n  return [currentResult, executeQuery];\n}\n","// eslint-disable react-hooks/exhaustive-deps\n\nimport { DocumentNode } from 'graphql';\nimport { pipe, subscribe, onEnd } from 'wonka';\nimport { useEffect, useState, useCallback, useMemo, useRef } from 'react';\n\nimport {\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\nimport { initialState, computeNextState, hasDepsChanged } from './state';\n\nexport interface UseSubscriptionArgs<Variables = object, Data = any> {\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  variables?: Variables;\n  pause?: boolean;\n  context?: Partial<OperationContext>;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport interface UseSubscriptionState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseSubscriptionResponse<Data = any, Variables = object> = [\n  UseSubscriptionState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport function useSubscription<Data = any, Result = Data, Variables = object>(\n  args: UseSubscriptionArgs<Variables, Data>,\n  handler?: SubscriptionHandler<Data, Result>\n): UseSubscriptionResponse<Result, Variables> {\n  const client = useClient();\n  const request = useRequest<Data, Variables>(args.query, args.variables);\n\n  const handlerRef = useRef<SubscriptionHandler<Data, Result> | undefined>(\n    handler\n  );\n  handlerRef.current = handler;\n\n  const source = useMemo(\n    () =>\n      !args.pause ? client.executeSubscription(request, args.context) : null,\n    [client, request, args.pause, args.context]\n  );\n\n  const deps = [client, request, args.context, args.pause] as const;\n\n  const [state, setState] = useState(\n    () => [source, { ...initialState, fetching: !!source }, deps] as const\n  );\n\n  let currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([\n      source,\n      (currentResult = computeNextState(state[1], { fetching: !!source })),\n      deps,\n    ]);\n  }\n\n  useEffect(() => {\n    const updateResult = (\n      result: Partial<UseSubscriptionState<Data, Variables>>\n    ) => {\n      setState(state => {\n        const nextResult = computeNextState(state[1], result);\n        if (state[1] === nextResult) return state;\n        if (handlerRef.current && state[1].data !== nextResult.data) {\n          nextResult.data = handlerRef.current(\n            state[1].data,\n            nextResult.data!\n          ) as any;\n        }\n\n        return [state[0], nextResult as any, state[2]];\n      });\n    };\n\n    if (state[0]) {\n      return pipe(\n        state[0],\n        onEnd(() => {\n          updateResult({ fetching: false });\n        }),\n        subscribe(updateResult)\n      ).unsubscribe;\n    } else {\n      updateResult({ fetching: false });\n    }\n  }, [state[0]]);\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const source = client.executeSubscription(request, {\n        ...args.context,\n        ...opts,\n      });\n\n      setState(state => [source, state[1], state[2]]);\n    },\n    [client, args.context, request]\n  );\n\n  return [currentResult, executeSubscription];\n}\n","import { DocumentNode } from 'graphql';\nimport { ReactElement } from 'react';\nimport {\n  TypedDocumentNode,\n  OperationResult,\n  OperationContext,\n} from '@urql/core';\nimport { useMutation, UseMutationState } from '../hooks';\n\nexport interface MutationProps<Data = any, Variables = object> {\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  children: (arg: MutationState<Data, Variables>) => ReactElement<any>;\n}\n\nexport interface MutationState<Data = any, Variables = object>\n  extends UseMutationState<Data, Variables> {\n  executeMutation: (\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<Data, Variables>>;\n}\n\nexport function Mutation<Data = any, Variables = any>(\n  props: MutationProps<Data, Variables>\n): ReactElement<any> {\n  const mutation = useMutation<Data, Variables>(props.query);\n  return props.children({ ...mutation[0], executeMutation: mutation[1] });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\nimport { useQuery, UseQueryArgs, UseQueryState } from '../hooks';\n\nexport interface QueryProps<Data = any, Variables = object>\n  extends UseQueryArgs<Variables, Data> {\n  children: (arg: QueryState<Data, Variables>) => ReactElement<any>;\n}\n\nexport interface QueryState<Data = any, Variables = object>\n  extends UseQueryState<Data, Variables> {\n  executeQuery: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Query<Data = any, Variables = any>(\n  props: QueryProps<Data, Variables>\n): ReactElement<any> {\n  const query = useQuery<Data, Variables>(props);\n  return props.children({ ...query[0], executeQuery: query[1] });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  SubscriptionHandler,\n} from '../hooks';\n\nexport interface SubscriptionProps<\n  Data = any,\n  Result = Data,\n  Variables = object\n> extends UseSubscriptionArgs<Variables, Data> {\n  handler?: SubscriptionHandler<Data, Result>;\n  children: (arg: SubscriptionState<Result, Variables>) => ReactElement<any>;\n}\n\nexport interface SubscriptionState<Data = any, Variables = object>\n  extends UseSubscriptionState<Data, Variables> {\n  executeSubscription: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Subscription<Data = any, Result = Data, Variables = object>(\n  props: SubscriptionProps<Data, Result, Variables>\n): ReactElement<any> {\n  const subscription = useSubscription<Data, Result, Variables>(\n    props,\n    props.handler\n  );\n\n  return props.children({\n    ...subscription[0],\n    executeSubscription: subscription[1],\n  });\n}\n","import { createContext, useContext } from 'react';\nimport { Client, createClient } from '@urql/core';\n\n// We assume some default options here; mainly not to actually be used\n// but not to error catastrophically if someone is just playing around\nconst defaultClient = createClient({ url: '/graphql' });\n\nexport const Context = createContext<Client>(defaultClient);\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\n\nlet hasWarnedAboutDefault = false;\n\nexport const useClient = (): Client => {\n  const client = useContext(Context);\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    client === defaultClient &&\n    !hasWarnedAboutDefault\n  ) {\n    hasWarnedAboutDefault = true;\n\n    console.warn(\n      \"Default Client: No client has been specified using urql's Provider.\" +\n        'This means that urql will be falling back to defaults including making ' +\n        'requests to `/graphql`.\\n' +\n        \"If that's not what you want, please create a client and add a Provider.\"\n    );\n  }\n\n  return client;\n};\n","export const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n  operation: undefined,\n};\n\nconst isShallowDifferent = (a: any, b: any) => {\n  if (typeof a != 'object' || typeof b != 'object') return a !== b;\n  for (const x in a) if (!(x in b)) return true;\n  for (const x in b) if (a[x] !== b[x]) return true;\n  return false;\n};\n\ninterface Stateish {\n  fetching: boolean;\n  stale: boolean;\n}\n\nexport const computeNextState = <T extends Stateish>(\n  prevState: T,\n  result: Partial<T>\n): T => {\n  const newState = {\n    ...prevState,\n    ...result,\n    fetching: !!result.fetching,\n    stale: !!result.stale,\n  };\n\n  return isShallowDifferent(prevState, newState) ? newState : prevState;\n};\n\nexport const hasDepsChanged = <T extends { length: number }>(a: T, b: T) => {\n  for (let i = 0, l = b.length; i < l; i++) if (a[i] !== b[i]) return true;\n  return false;\n};\n","import { pipe, subscribe } from 'wonka';\nimport { Client, OperationResult } from '@urql/core';\n\ntype CacheEntry = OperationResult | Promise<unknown> | undefined;\n\ninterface Cache {\n  get(key: number): CacheEntry;\n  set(key: number, value: CacheEntry): void;\n  dispose(key: number): void;\n}\n\ninterface ClientWithCache extends Client {\n  _react?: Cache;\n}\n\nexport const getCacheForClient = (client: Client): Cache => {\n  if (!(client as ClientWithCache)._react) {\n    const reclaim = new Set();\n    const map = new Map<number, CacheEntry>();\n\n    if (client.operations$ /* not available in mocks */) {\n      pipe(\n        client.operations$,\n        subscribe(operation => {\n          if (operation.kind === 'teardown' && reclaim.has(operation.key)) {\n            reclaim.delete(operation.key);\n            map.delete(operation.key);\n          }\n        })\n      );\n    }\n\n    (client as ClientWithCache)._react = {\n      get(key) {\n        return map.get(key);\n      },\n      set(key, value) {\n        reclaim.delete(key);\n        map.set(key, value);\n      },\n      dispose(key) {\n        reclaim.add(key);\n      },\n    };\n  }\n\n  return (client as ClientWithCache)._react!;\n};\n"]},"metadata":{},"sourceType":"module"}