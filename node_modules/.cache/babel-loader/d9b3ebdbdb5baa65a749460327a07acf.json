{"ast":null,"code":"function t(a) {\n  return \"string\" == typeof a ? a : null;\n}\n\nfunction v(a, e, g) {\n  var c, b, d, l, p;\n\n  for (c = new Set(), b = 0, d = e.length; b < d; b++) {\n    \"string\" == typeof (l = a.resolve(e[b], \"node\")) && c.add(l);\n  }\n\n  e = e.slice();\n  b = 0;\n\n  for (d = g.length; b < d; b++) {\n    \"string\" != typeof (p = a.resolve(l = g[b], \"node\")) || c.has(p) || (c.add(p), e.push(l));\n  }\n\n  return e;\n}\n\nfunction C(a, e) {\n  var g, c, b, d;\n\n  for (g = new Set(), c = 0, b = a.length; c < b; c++) {\n    \"string\" == typeof (d = a[c]) && g.add(d);\n  }\n\n  a = a.slice();\n  c = 0;\n\n  for (b = e.length; c < b; c++) {\n    \"string\" != typeof (d = e[c]) || g.has(d) || (g.add(d), a.push(d));\n  }\n\n  return a;\n}\n\nfunction D(a, e) {\n  var g, c, b, d;\n\n  for (g in e) {\n    if (\"first\" !== g && \"last\" !== g && \"after\" !== g && \"before\" !== g) {\n      if (!(g in a)) {\n        return !1;\n      }\n\n      if (typeof (c = a[g]) != typeof (b = e[g]) || \"object\" != typeof c ? c !== b : stringifyVariables(c) !== stringifyVariables(b)) {\n        return !1;\n      }\n    }\n  }\n\n  for (d in a) {\n    if (\"first\" !== d && \"last\" !== d && \"after\" !== d && \"before\" !== d && !(d in e)) {\n      return !1;\n    }\n  }\n\n  return !0;\n}\n\nfunction E(a, e, g) {\n  var b,\n      d,\n      l,\n      p,\n      c = t(a.resolve(e, g));\n\n  if (!c) {\n    return null;\n  }\n\n  g = a.resolve(c, \"__typename\");\n  e = a.resolve(c, \"edges\") || [];\n  b = a.resolve(c, \"nodes\") || [];\n\n  if (\"string\" != typeof g) {\n    return null;\n  }\n\n  g = {\n    __typename: g,\n    edges: e,\n    nodes: b,\n    pageInfo: r\n  };\n\n  if (\"string\" == typeof (d = a.resolve(c, \"pageInfo\"))) {\n    c = t(a.resolve(d, \"__typename\"));\n    b = t(a.resolve(d, \"endCursor\"));\n    l = t(a.resolve(d, \"startCursor\")), p = a.resolve(d, \"hasNextPage\");\n    d = a.resolve(d, \"hasPreviousPage\");\n    null === (c = g.pageInfo = {\n      __typename: \"string\" == typeof c ? c : \"PageInfo\",\n      hasNextPage: \"boolean\" == typeof p ? p : !!b,\n      hasPreviousPage: \"boolean\" == typeof d ? d : !!l,\n      endCursor: b,\n      startCursor: l\n    }).endCursor && (b = e[e.length - 1]) && (b = a.resolve(b, \"cursor\"), c.endCursor = t(b));\n    null === c.startCursor && (e = e[0]) && (a = a.resolve(e, \"cursor\"), c.startCursor = t(a));\n  }\n\n  return g;\n}\n\nfunction relayPagination(a) {\n  void 0 === a && (a = {});\n  var e = a.mergeMode || \"inwards\";\n  return function (a, c, b, d) {\n    var g, p, w, A, m, u, q, n, k, x, h, f, y, z;\n    g = d.fieldName;\n\n    if (0 !== (w = (p = b.inspectFields(a = d.parentKey).filter(function (a) {\n      return a.fieldName === g;\n    })).length)) {\n      for (A = null, m = [], u = [], q = [], n = [], k = _extends({}, r), x = 0; x < w; x++) {\n        f = (h = p[x]).fieldKey;\n\n        if (null !== (h = h.arguments) && D(c, h) && null !== (f = E(b, a, f))) {\n          if (\"inwards\" === e && \"number\" == typeof h.last && \"number\" == typeof h.first) {\n            k = f.edges.slice(0, h.first + 1);\n            y = f.edges.slice(-h.last), z = f.nodes.slice(0, h.first + 1);\n            h = f.nodes.slice(-h.last);\n            m = v(b, m, k);\n            u = v(b, y, u);\n            q = C(q, z);\n            n = C(h, n);\n            k = f.pageInfo;\n          } else {\n            h.after ? (m = v(b, m, f.edges), q = C(q, f.nodes), k.endCursor = f.pageInfo.endCursor, k.hasNextPage = f.pageInfo.hasNextPage) : h.before ? (u = v(b, f.edges, u), n = C(f.nodes, n), k.startCursor = f.pageInfo.startCursor, k.hasPreviousPage = f.pageInfo.hasPreviousPage) : (\"number\" == typeof h.last ? (u = v(b, f.edges, u), n = C(f.nodes, n)) : (m = v(b, m, f.edges), q = C(q, f.nodes)), k = f.pageInfo);\n          }\n\n          f.pageInfo.__typename !== k.__typename && (k.__typename = f.pageInfo.__typename);\n          A !== f.__typename && (A = f.__typename);\n        }\n      }\n\n      if (\"string\" == typeof A) {\n        if (!t(b.resolve(a, g, c))) {\n          if (d.store.schema) {\n            d.partial = !0;\n          } else {\n            return;\n          }\n        }\n\n        return {\n          __typename: A,\n          edges: \"inwards\" === e ? v(b, m, u) : v(b, u, m),\n          nodes: \"inwards\" === e ? C(q, n) : C(n, q),\n          pageInfo: {\n            __typename: k.__typename,\n            endCursor: k.endCursor,\n            startCursor: k.startCursor,\n            hasNextPage: k.hasNextPage,\n            hasPreviousPage: k.hasPreviousPage\n          }\n        };\n      }\n    }\n  };\n}\n\nfunction simplePagination(a) {\n  function e(a, b) {\n    var d, e, l, m;\n\n    for (d in b) {\n      if (d !== g && d !== c) {\n        if (!(d in a)) {\n          return !1;\n        }\n\n        if (typeof (e = a[d]) != typeof (l = b[d]) || \"object\" != typeof e ? e !== l : stringifyVariables(e) !== stringifyVariables(l)) {\n          return !1;\n        }\n      }\n    }\n\n    for (m in a) {\n      if (m !== g && m !== c && !(m in b)) {\n        return !1;\n      }\n    }\n\n    return !0;\n  }\n\n  var g, c, b;\n  void 0 === a && (a = {});\n  void 0 === (g = a.offsetArgument) && (g = \"skip\");\n  void 0 === (c = a.limitArgument) && (c = \"limit\");\n  void 0 === (b = a.mergeMode) && (b = \"after\");\n  return function (a, c, p, w) {\n    var d, m, l, q, n, k, x, h, f, y, z, B;\n    d = w.fieldName;\n\n    if (0 !== (l = (m = p.inspectFields(a = w.parentKey).filter(function (a) {\n      return a.fieldName === d;\n    })).length)) {\n      for (q = new Set(), n = [], k = null, x = 0; x < l; x++) {\n        f = (h = m[x]).fieldKey;\n\n        if (null !== (h = h.arguments) && e(c, h) && (f = p.resolve(a, f), h = h[g], null !== f && 0 !== f.length && \"number\" == typeof h)) {\n          for (y = [], z = 0; z < f.length; z++) {\n            q.has(B = f[z]) || (y.push(B), q.add(B));\n          }\n\n          n = (!k || h > k) == (\"after\" === b) ? n.concat(y) : y.concat(n);\n          k = h;\n        }\n      }\n\n      if (p.resolve(a, d, c)) {\n        return n;\n      }\n\n      if (w.store.schema) {\n        return w.partial = !0, n;\n      }\n    }\n  };\n}\n\nimport { stringifyVariables } from \"@urql/core\";\nimport { _ as _extends } from \"./5301ccd2.mjs\";\nvar r = {\n  __typename: \"PageInfo\",\n  endCursor: null,\n  startCursor: null,\n  hasNextPage: !1,\n  hasPreviousPage: !1\n};\nexport { relayPagination, simplePagination };","map":{"version":3,"sources":["../src/extras/relayPagination.ts","../src/extras/simplePagination.ts"],"names":["newEdges","ids","i","newNodes","key","D","link","cache","endCursor","ensureKey","pageInfoKey","size","lastEdges","endNodes","startEdges","fieldArgs","connectionArgs","_parent","entityKey","allFields","info","result"],"mappings":"AA8CQA,SAAAA,CAAAA,CAAAA,CAAAA,EAAAA;;;;;;;0BAI6BC,C,EAAAA,CAAAA,GAAAA,CAAAA,CAAAA,M,EAC/BA,CAAAA,GAAAA,C,EAAAA,CAAAA,E,EAAAA;;;;;;;;4DAmB0CC,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,C,KAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,C;;;SAQvCC,C;;;WAOIC,C,EAAAA,C,EAAAA;;;;4BAQIA,CAAAA,CAAAA,CAAAA,C,KAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,C;;;;;;;;;;;;;SA6BRC,C,CAAAA,C,EAAAA,C,EAAAA;eA2B0BE,C;;;;AAnB3BD,UAAAA,EAAiBC,CAAAA,IAAAA,CAAjBD,CAAAA,EAAiBC;;;;AAMC,UAAA,QAAA,CAAA,GAAA,CAAA,CAHOD,CAGP,CAAA,KAHOA,QAAAA,CAAAA,GAAAA,CAAAA,CACFA,CADEA,CAAAA,CAGP,IAFKA,YAAAA,OAAAA,CAEL,GAFKA,CAAAA,KAAAA,CAEL,GAFKA,kBAAAA,CAAAA,CAAAA,CAAAA,KAAAA,kBAAAA,CAAAA,CAAAA,CAEL,EAFKA;;;;;;OAeIC,C,IAAAA,C,EAAAA;QACbE,YAAwBC,CAAxBD,IAAwBC,WAApCF,CAAYC,IAAZD,YAAAA,CAAYC,IAAZD,aAAAA,CAAYC,IAAZD,EAAAA,CAAAA,IAAAA,CAAAA,C,EAAAA;cACcC,C;;;;;;;;;;;;;;;;;;;QAyCdE,O,CAAAA,C,EAAAA,O,KAAAA,E;;;;;;;;gBA6BIC,C;;;;;;2CAONC,U,IAAAA;uBAIAC,Y;;;;;;;;;;;;;;;;;;aCvNJC,C,KAAAA,CAAAA,GAAAA,E;;;;;;;6BAWeC,C;;;;;;;;;;;;;;kBAqBTC,Q;;6BAGYV,C,EAAAA,C,EAAAA,CAAAA,CAAAA,K,GAAoBW,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,EACnBC,CAAAA,CAAAA,KADmBD,C,EACFE,CAAAA,CAAAA,SAAAA,GAAAA,CAAAA,CAAAA,QAAAA,CAAAA,S;;;;;;;;;;;;;;;;;eAkD3BC;uBAAAA;AACID,UAAAA,KAAAA,EAAAA,cAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,CADJC;+BAKAA,C,GAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,C,GAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CALAA;;;;;;;;AAAAA,S;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8BD/EqB,gB;;;;;gBAepB,C","sourcesContent":["import { stringifyVariables } from '@urql/core';\nimport { Cache, Resolver, Variables, NullArray } from '../types';\n\nexport type MergeMode = 'outwards' | 'inwards';\n\nexport interface PaginationParams {\n  mergeMode?: MergeMode;\n}\n\ninterface PageInfo {\n  __typename: string;\n  endCursor: null | string;\n  startCursor: null | string;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n}\n\ninterface Page {\n  __typename: string;\n  edges: NullArray<string>;\n  nodes: NullArray<string>;\n  pageInfo: PageInfo;\n}\n\nconst defaultPageInfo: PageInfo = {\n  __typename: 'PageInfo',\n  endCursor: null,\n  startCursor: null,\n  hasNextPage: false,\n  hasPreviousPage: false,\n};\n\nconst ensureKey = (x: any): string | null => (typeof x === 'string' ? x : null);\n\nconst concatEdges = (\n  cache: Cache,\n  leftEdges: NullArray<string>,\n  rightEdges: NullArray<string>\n) => {\n  const ids = new Set<string>();\n  for (let i = 0, l = leftEdges.length; i < l; i++) {\n    const edge = leftEdges[i];\n    const node = cache.resolve(edge, 'node');\n    if (typeof node === 'string') ids.add(node);\n  }\n\n  const newEdges = leftEdges.slice();\n  for (let i = 0, l = rightEdges.length; i < l; i++) {\n    const edge = rightEdges[i];\n    const node = cache.resolve(edge, 'node');\n    if (typeof node === 'string' && !ids.has(node)) {\n      ids.add(node);\n      newEdges.push(edge);\n    }\n  }\n\n  return newEdges;\n};\n\nconst concatNodes = (\n  leftNodes: NullArray<string>,\n  rightNodes: NullArray<string>\n) => {\n  const ids = new Set<string>();\n  for (let i = 0, l = leftNodes.length; i < l; i++) {\n    const node = leftNodes[i];\n    if (typeof node === 'string') ids.add(node);\n  }\n\n  const newNodes = leftNodes.slice();\n  for (let i = 0, l = rightNodes.length; i < l; i++) {\n    const node = rightNodes[i];\n    if (typeof node === 'string' && !ids.has(node)) {\n      ids.add(node);\n      newNodes.push(node);\n    }\n  }\n\n  return newNodes;\n};\n\nconst compareArgs = (\n  fieldArgs: Variables,\n  connectionArgs: Variables\n): boolean => {\n  for (const key in connectionArgs) {\n    if (\n      key === 'first' ||\n      key === 'last' ||\n      key === 'after' ||\n      key === 'before'\n    ) {\n      continue;\n    } else if (!(key in fieldArgs)) {\n      return false;\n    }\n\n    const argA = fieldArgs[key];\n    const argB = connectionArgs[key];\n\n    if (\n      typeof argA !== typeof argB || typeof argA !== 'object'\n        ? argA !== argB\n        : stringifyVariables(argA) !== stringifyVariables(argB)\n    ) {\n      return false;\n    }\n  }\n\n  for (const key in fieldArgs) {\n    if (\n      key === 'first' ||\n      key === 'last' ||\n      key === 'after' ||\n      key === 'before'\n    ) {\n      continue;\n    }\n\n    if (!(key in connectionArgs)) return false;\n  }\n\n  return true;\n};\n\nconst getPage = (\n  cache: Cache,\n  entityKey: string,\n  fieldKey: string\n): Page | null => {\n  const link = ensureKey(cache.resolve(entityKey, fieldKey));\n  if (!link) return null;\n\n  const typename = cache.resolve(link, '__typename') as string;\n  const edges = (cache.resolve(link, 'edges') || []) as NullArray<string>;\n  const nodes = (cache.resolve(link, 'nodes') || []) as NullArray<string>;\n  if (typeof typename !== 'string') {\n    return null;\n  }\n\n  const page: Page = {\n    __typename: typename,\n    edges,\n    nodes,\n    pageInfo: defaultPageInfo,\n  };\n\n  const pageInfoKey = cache.resolve(link, 'pageInfo');\n  if (typeof pageInfoKey === 'string') {\n    const pageInfoType = ensureKey(cache.resolve(pageInfoKey, '__typename'));\n    const endCursor = ensureKey(cache.resolve(pageInfoKey, 'endCursor'));\n    const startCursor = ensureKey(cache.resolve(pageInfoKey, 'startCursor'));\n    const hasNextPage = cache.resolve(pageInfoKey, 'hasNextPage');\n    const hasPreviousPage = cache.resolve(pageInfoKey, 'hasPreviousPage');\n\n    const pageInfo: PageInfo = (page.pageInfo = {\n      __typename: typeof pageInfoType === 'string' ? pageInfoType : 'PageInfo',\n      hasNextPage: typeof hasNextPage === 'boolean' ? hasNextPage : !!endCursor,\n      hasPreviousPage:\n        typeof hasPreviousPage === 'boolean' ? hasPreviousPage : !!startCursor,\n      endCursor,\n      startCursor,\n    });\n\n    if (pageInfo.endCursor === null) {\n      const edge = edges[edges.length - 1];\n      if (edge) {\n        const endCursor = cache.resolve(edge, 'cursor');\n        pageInfo.endCursor = ensureKey(endCursor);\n      }\n    }\n\n    if (pageInfo.startCursor === null) {\n      const edge = edges[0];\n      if (edge) {\n        const startCursor = cache.resolve(edge, 'cursor');\n        pageInfo.startCursor = ensureKey(startCursor);\n      }\n    }\n  }\n\n  return page;\n};\n\nexport const relayPagination = (params: PaginationParams = {}): Resolver => {\n  const mergeMode = params.mergeMode || 'inwards';\n\n  return (_parent, fieldArgs, cache, info) => {\n    const { parentKey: entityKey, fieldName } = info;\n\n    const allFields = cache.inspectFields(entityKey);\n    const fieldInfos = allFields.filter(info => info.fieldName === fieldName);\n    const size = fieldInfos.length;\n    if (size === 0) {\n      return undefined;\n    }\n\n    let typename: string | null = null;\n    let startEdges: NullArray<string> = [];\n    let endEdges: NullArray<string> = [];\n    let startNodes: NullArray<string> = [];\n    let endNodes: NullArray<string> = [];\n    let pageInfo: PageInfo = { ...defaultPageInfo };\n\n    for (let i = 0; i < size; i++) {\n      const { fieldKey, arguments: args } = fieldInfos[i];\n      if (args === null || !compareArgs(fieldArgs, args)) {\n        continue;\n      }\n\n      const page = getPage(cache, entityKey, fieldKey);\n      if (page === null) {\n        continue;\n      }\n\n      if (\n        mergeMode === 'inwards' &&\n        typeof args.last === 'number' &&\n        typeof args.first === 'number'\n      ) {\n        const firstEdges = page.edges.slice(0, args.first + 1);\n        const lastEdges = page.edges.slice(-args.last);\n        const firstNodes = page.nodes.slice(0, args.first + 1);\n        const lastNodes = page.nodes.slice(-args.last);\n\n        startEdges = concatEdges(cache, startEdges, firstEdges);\n        endEdges = concatEdges(cache, lastEdges, endEdges);\n        startNodes = concatNodes(startNodes, firstNodes);\n        endNodes = concatNodes(lastNodes, endNodes);\n\n        pageInfo = page.pageInfo;\n      } else if (args.after) {\n        startEdges = concatEdges(cache, startEdges, page.edges);\n        startNodes = concatNodes(startNodes, page.nodes);\n        pageInfo.endCursor = page.pageInfo.endCursor;\n        pageInfo.hasNextPage = page.pageInfo.hasNextPage;\n      } else if (args.before) {\n        endEdges = concatEdges(cache, page.edges, endEdges);\n        endNodes = concatNodes(page.nodes, endNodes);\n        pageInfo.startCursor = page.pageInfo.startCursor;\n        pageInfo.hasPreviousPage = page.pageInfo.hasPreviousPage;\n      } else if (typeof args.last === 'number') {\n        endEdges = concatEdges(cache, page.edges, endEdges);\n        endNodes = concatNodes(page.nodes, endNodes);\n        pageInfo = page.pageInfo;\n      } else {\n        startEdges = concatEdges(cache, startEdges, page.edges);\n        startNodes = concatNodes(startNodes, page.nodes);\n        pageInfo = page.pageInfo;\n      }\n\n      if (page.pageInfo.__typename !== pageInfo.__typename)\n        pageInfo.__typename = page.pageInfo.__typename;\n      if (typename !== page.__typename) typename = page.__typename;\n    }\n\n    if (typeof typename !== 'string') {\n      return undefined;\n    }\n\n    const hasCurrentPage = !!ensureKey(\n      cache.resolve(entityKey, fieldName, fieldArgs)\n    );\n    if (!hasCurrentPage) {\n      if (!(info as any).store.schema) {\n        return undefined;\n      } else {\n        info.partial = true;\n      }\n    }\n\n    return {\n      __typename: typename,\n      edges:\n        mergeMode === 'inwards'\n          ? concatEdges(cache, startEdges, endEdges)\n          : concatEdges(cache, endEdges, startEdges),\n      nodes:\n        mergeMode === 'inwards'\n          ? concatNodes(startNodes, endNodes)\n          : concatNodes(endNodes, startNodes),\n      pageInfo: {\n        __typename: pageInfo.__typename,\n        endCursor: pageInfo.endCursor,\n        startCursor: pageInfo.startCursor,\n        hasNextPage: pageInfo.hasNextPage,\n        hasPreviousPage: pageInfo.hasPreviousPage,\n      },\n    };\n  };\n};\n","import { stringifyVariables } from '@urql/core';\nimport { Resolver, Variables, NullArray } from '../types';\n\nexport type MergeMode = 'before' | 'after';\n\nexport interface PaginationParams {\n  offsetArgument?: string;\n  limitArgument?: string;\n  mergeMode?: MergeMode;\n}\n\nexport const simplePagination = ({\n  offsetArgument = 'skip',\n  limitArgument = 'limit',\n  mergeMode = 'after',\n}: PaginationParams = {}): Resolver => {\n  const compareArgs = (\n    fieldArgs: Variables,\n    connectionArgs: Variables\n  ): boolean => {\n    for (const key in connectionArgs) {\n      if (key === offsetArgument || key === limitArgument) {\n        continue;\n      } else if (!(key in fieldArgs)) {\n        return false;\n      }\n\n      const argA = fieldArgs[key];\n      const argB = connectionArgs[key];\n\n      if (\n        typeof argA !== typeof argB || typeof argA !== 'object'\n          ? argA !== argB\n          : stringifyVariables(argA) !== stringifyVariables(argB)\n      ) {\n        return false;\n      }\n    }\n\n    for (const key in fieldArgs) {\n      if (key === offsetArgument || key === limitArgument) {\n        continue;\n      }\n      if (!(key in connectionArgs)) return false;\n    }\n\n    return true;\n  };\n\n  return (_parent, fieldArgs, cache, info) => {\n    const { parentKey: entityKey, fieldName } = info;\n\n    const allFields = cache.inspectFields(entityKey);\n    const fieldInfos = allFields.filter(info => info.fieldName === fieldName);\n    const size = fieldInfos.length;\n    if (size === 0) {\n      return undefined;\n    }\n\n    const visited = new Set();\n    let result: NullArray<string> = [];\n    let prevOffset: number | null = null;\n\n    for (let i = 0; i < size; i++) {\n      const { fieldKey, arguments: args } = fieldInfos[i];\n      if (args === null || !compareArgs(fieldArgs, args)) {\n        continue;\n      }\n\n      const links = cache.resolve(entityKey, fieldKey) as string[];\n      const currentOffset = args[offsetArgument];\n\n      if (\n        links === null ||\n        links.length === 0 ||\n        typeof currentOffset !== 'number'\n      ) {\n        continue;\n      }\n\n      const tempResult: NullArray<string> = [];\n\n      for (let j = 0; j < links.length; j++) {\n        const link = links[j];\n        if (visited.has(link)) continue;\n        tempResult.push(link);\n        visited.add(link);\n      }\n\n      if (\n        (!prevOffset || currentOffset > prevOffset) ===\n        (mergeMode === 'after')\n      ) {\n        result = [...result, ...tempResult];\n      } else {\n        result = [...tempResult, ...result];\n      }\n\n      prevOffset = currentOffset;\n    }\n\n    const hasCurrentPage = cache.resolve(entityKey, fieldName, fieldArgs);\n    if (hasCurrentPage) {\n      return result;\n    } else if (!(info as any).store.schema) {\n      return undefined;\n    } else {\n      info.partial = true;\n      return result;\n    }\n  };\n};\n"]},"metadata":{},"sourceType":"module"}